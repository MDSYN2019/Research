/*

The original link for this tutorial is here: https://github.com/CrawfordGroup/ProgrammingProjects/tree/master/Project%2302

======================================================
Normal Coordinate Analysis and the Vibrational Spectrum 
=======================================================

The essential theoretical step is the transformation of the kinetic and potential energy operators 
from simple Cartesian displacement coordinates to so-called "normal coordinates"

------------------------
Last Updated: 13/11/2020
------------------------

 */


#include <iostream>
#include <iomanip>
#include <string>
#include <fstream>
#include <sstream>
#include <vector>
#include <cstdlib>
#include <iterator>
#include <sstream>
#include <cmath>
#include <tuple> // To return multiple values from a c++ function
// New part - variant! 
#include <variant>
// Importing Eigen libraries
#include <Eigen/Dense>
#include <Eigen/Eigenvalues> 

std::vector<double> vecX, vecY, vecZ;
std::vector<double> StructMass, StructVecX, StructVecY, StructVecZ;
std::vector<double> Total; 
std::vector<double> MassSquareHessian; 
std::vector<double> rootMasses; 

double x, y, z;
double mass, structx, structy, structz;

// h2o_geom.txt  h2o_hessian.txt

int main(void) {

  // (12 *3 )^2 = 1296
  int index = 0;
  std::string HessianPath = "/home/synoh/Desktop/2020Goals/QChem/Programming/ProgrammingProjects/Project#02/input/h2o_hessian.txt"; // Path of the Hessian 
  std::string structurePath = "/home/synoh/Desktop/2020Goals/QChem/Programming/ProgrammingProjects/Project#02/input/h2o_geom.txt";
  std::ifstream input(HessianPath); // Reading Hessian file 
  std::ifstream Structinput; // Reading the structure file 
  
  Structinput.open(structurePath);
  
  input.ignore(10, '\n'); // Ignore the first 10 lines or until first \n, whichever comes first
  Structinput.ignore(10, '\n'); // Ignore the first 10 lines or until first \n, whichever comes first

  std::string line;
  while (input >> x >> y >> z) {
      vecX.push_back(x);
      vecY.push_back(y);
      vecZ.push_back(z);
  }

  while (Structinput >> mass >> structx >> structy >> structz) {
    StructMass.push_back(mass);
    StructVecX.push_back(structx);
    StructVecY.push_back(structy);
    StructVecZ.push_back(structz);
  }

  /*
    The Hessian stored in memory should be a square matrix, while the format of the input file is rectangular. 
    Understanding the translation between the two takes a bit of thinking. Here's a partial code block that works 
    for this purpose:
    
    https://github.com/CrawfordGroup/ProgrammingProjects/blob/master/Project%2302/hints/hint1.md
  */
  
  const int Length = vecY.size();
  Eigen::MatrixXd m(Length,3);

  for(int i(0); i < vecX.size(); i++) {
    //std::cout << vecX[i] << ", " << vecY[i] << " " << vecZ[i]  << std::endl;
    m(i,0) = vecX[i];
    m(i,1) = vecY[i];
    m(i,2) = vecZ[i];
  }

  int counter = 0;
  // As the dimensions of the hessian is .., we need to replicate the values by 3. 
  while (counter <= 2) {
    for (auto i = StructMass.begin(); i != StructMass.end(); ++i) { 
      for (auto j = StructMass.begin(); j != StructMass.end(); ++j) {
	rootMasses.push_back(std::sqrt((*i) * (*j)));   
      }
    }
    counter += 1;
  }
  /*
  TODO - may need to package this up into a function to make my life a bit easier in the future 
  https://stackoverflow.com/questions/17036818/initialise-eigenvector-with-stdvector - Useful link 
  */
  double* ptr = &rootMasses[0]; // ro
  Eigen::Map<Eigen::VectorXd> my_vect(ptr, rootMasses.size());
  //  Eigen::Map<Eigen::Vector3d> v2(rootMasses);
  for (std::vector<double>::const_iterator i = rootMasses.begin(); i != rootMasses.end(); ++i) {
    std::cout << "The root masses are: " <<  *i << std::endl;
    int rowIndex =  i - rootMasses.begin();
    m.row(rowIndex)  = m.row(rowIndex); /// (*i);  // Divide each element of the Hessian matrix by the product of the square roots of the masses of the atoms with the given coordinates 
  }
  m.transposeInPlace(); // Transpose the data 
  Eigen::VectorXd B(Eigen::Map<Eigen::VectorXd>(m.data(), m.cols() * m.rows()));
  //std::cout << B.data() << std::endl;
  std::vector<double> v2;
  v2.resize(B.size());
  Eigen::VectorXd::Map(&v2[0], B.size()) = B;
  for (std::vector<double>::const_iterator i = v2.begin(); i != v2.end(); ++i) {
    //std::cout << *i << std::endl;
  }
  for (std::vector<double>::const_iterator i = rootMasses.begin(); i != rootMasses.end(); ++i) {
    std::cout << *i << std::endl;
  }
  Eigen::Map<Eigen::MatrixXd> M2(B.data(), 9,9);
  std::cout << M2 << std::endl;

  /*
    Read the Hessian matrix from hessian.dat. The integer on the first line is the number of atoms, while the remaining values represent the second-derivatives 
    of the potential energies with respect to the (non-mass weighed) Cartesian coordinates of the atoms 
  */

  Structinput.close();
  Eigen::EigenSolver<Eigen::MatrixXd> es(M2);
  std::cout << "The eigenvalues of the Hessian is:" << std::endl << es.eigenvalues() << std::endl;
  std::cout << "The matrix of eigenvectors, V, is:" << std::endl << es.eigenvectors() << std::endl << std::endl;
  Eigen::SelfAdjointEigenSolver<Eigen::MatrixXd> solver(M2);
  Eigen::MatrixXd evecs = solver.eigenvectors();
  Eigen::MatrixXd evals = solver.eigenvalues();
  std::cout << "The eigenvalues of the Hessian is:" << std::endl << evals << std::endl;
  std::cout << "The matrix of eigenvectors, V, is:" << std::endl << evecs << std::endl << std::endl;

  return 0;
  
}
